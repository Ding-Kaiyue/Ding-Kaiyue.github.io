[{"title":"从硬编码到插件化（上篇）：脏架构的问题诊断","url":"/2025/11/01/%E4%BB%8E%E7%A1%AC%E7%BC%96%E7%A0%81%E5%88%B0%E6%8F%92%E4%BB%B6%E5%8C%96%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89%EF%BC%9A%E8%84%8F%E6%9E%B6%E6%9E%84%E7%9A%84%E9%97%AE%E9%A2%98%E8%AF%8A%E6%96%AD/","content":"\n这是一篇关于机器人控制系统架构设计的深度分析，揭示为什么简单堆积代码的方式会导致系统变得越来越脆弱。\n\n本文适合：架构设计师、ROS2 开发者、以及关心代码质量的工程师\n内容：从真实的混乱代码开始，分析 8 个严重的架构问题，然后通过 SOLID 原则揭示这些问题的根本原因。\n\n📖 本篇内容\n开篇：现实的困境\n脏架构的问题\n1.1 真实的混乱代码示例\n1.2 八个严重问题的具体分析\n1.3 问题的根本原因\n1.4 问题速览与症状总结\n\n\nSOLID 原则：理论基础\n\n\n开篇 - 一个现实的困境想象一下，你正在开发一个机器人控制系统。系统需要支持多种运动模式：\n\n关节速度控制（JointVelocity）\n笛卡尔空间速度控制（CartesianVelocity）\n关节空间插值（MoveJ）\n直线运动（MoveL）\n圆弧运动（MoveC）\n轨迹回放（TrajectoryReplay）\n…\n\n每个模式都是一个完整的控制算法，需要独立的消息处理、参数管理、状态维护。随着功能的增加，系统变得越来越复杂。\n问题来了：当你需要添加新的运动模式时，你要改动哪些地方？\n对我来说，这个问题的答案一开始非常”直接”——我在主控制节点（StateMachine）里添加新的回调、订阅新的话题、修改状态机逻辑……一切都在一个文件里完成。\n它”能跑”，甚至能运行得相当不错。但随着模式数量增加到 10、15、20 个，问题开始浮现。\n每次添加一个新的控制模式，我都要打开那个越来越膨胀的文件。光是找到要改的函数，就要滚动好半天。改完了一个 case，又得祈祷不会打断别的模式。两个人并行开发两个新模式？那就准备好解决 merge 冲突吧。\n系统变得越来越臃肿、越来越脆弱。修改一个地方要担心打破另一个地方。这，就是我后来称之为的 “脏架构（Dirty Architecture）”——不是说代码质量差，而是说职责混乱、耦合严重、无法优雅扩展。\n所谓脏架构，不是指代码写得丑，而是指系统的结构无法支撑长期演化。它能工作，但无法成长。\n接下来，我们从那段早期的真实代码开始，看看它到底”脏”在哪里——以及为什么会变成这样。\n\n快速对比：从脏到清洁的演变在深入问题之前，让我们先看一个”目标”——这样你能理解我们要解决什么问题：\n\n\n\n架构维度\n脏架构（Before）\n清洁架构（After）\n\n\n\n控制器注册\n手写 if-else &#x2F; switch-case\n动态注册（工厂 + YAML）\n\n\n控制器创建\nnew + 手动管理\n工厂方法自动创建\n\n\n添加新模式\n修改核心文件 6-8 处\n添加独立类文件 + 改 1 行 registry\n\n\n通信接口\n直接 ROS 订阅混在逻辑里\n统一的抽象接口（ModeControllerBase）\n\n\n配置方式\n硬编码在代码中\nYAML 配置驱动\n\n\n核心代码变化\n随功能数量线性增长\n保持稳定（与功能数无关）\n\n\n开发周期\n1-3 天&#x2F;控制器\n2-4 小时&#x2F;控制器\n\n\n可测试性\n无法单独测试\n控制器独立可测\n\n\n看这个对比表，你会发现：脏架构的核心问题是添加新功能要改动核心代码；清洁架构的核心优势是添加新功能无需改动核心代码。\n这就是我们在下篇要实现的目标。\n\n第一部分 - 脏架构的问题1.1 典型的脏架构是这样的这是我的真实项目 orz_robot 中早期的代码片段。看看构造函数里发生了什么：\n// robot_state_machine.hpp / robot_state_machine.cppclass StateMachine : public rclcpp::Node &#123;private:    std::map&lt;uint8_t, std::shared_ptr&lt;ModeControllerBase&gt;&gt; controller_map_;    uint8_t current_mode_;public:    StateMachine(std::string node_name) : Node(node_name), qos(10) &#123;        // 问题 1: 大量的订阅直接在构造函数里硬编码        mode_sub = this-&gt;create_subscription&lt;std_msgs::msg::UInt8&gt;(            &quot;robotic_arm_control_mode&quot;, qos,            std::bind(&amp;StateMachine::working_mode_callback, this, std::placeholders::_1));        jointctrl_sub_ = this-&gt;create_subscription&lt;robot_interfaces::msg::KeyPressedAction&gt;(            &quot;jointctrl_action&quot;, qos,            std::bind(&amp;StateMachine::jointctrl_action_callback, this, std::placeholders::_1));        cartesian_sub_ = this-&gt;create_subscription&lt;robot_interfaces::msg::KeyPressedAction&gt;(            &quot;cartesian_action&quot;, qos,            std::bind(&amp;StateMachine::cartesian_action_callback, this, std::placeholders::_1));        movej_sub_ = this-&gt;create_subscription&lt;std_msgs::msg::Float64MultiArray&gt;(            &quot;movej_action&quot;, qos,            std::bind(&amp;StateMachine::movej_action_callback, this, std::placeholders::_1));        movel_sub_ = this-&gt;create_subscription&lt;std_msgs::msg::Float64MultiArray&gt;(            &quot;movel_action&quot;, qos,            std::bind(&amp;StateMachine::movel_action_callback, this, std::placeholders::_1));        // ... 还有更多订阅 ...        // 这里已经有 10+ 个订阅，全部在构造函数中硬编码！    &#125;    void working_mode_callback(const std_msgs::msg::UInt8::SharedPtr msg) &#123;        current_mode_ = msg-&gt;data;        // 问题 2: 所有模式的逻辑都在一个巨大的 switch 中        switch (current_mode_) &#123;            case BACKTOSTART: &#123;                std::vector&lt;double&gt; target_joint_positions = &#123;0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f&#125;;                kinematics_-&gt;moveToJointPositions(target_joint_positions);                break;            &#125;            case DISABLE: &#123;                auto motor_control_msg = kinematics_-&gt;motor_disable();                motor_msg_pub-&gt;publish(motor_control_msg);                break;            &#125;            // ... 还有十几个 case，每个几十行代码 ...            // 这个函数有 200+ 行！        &#125;    &#125;&#125;;\n\n1.2 这个架构暴露的 8 个严重问题这 8 个问题看似独立，但其实可以分成三大类。让我一个个讲解：\n🔗 第一类：架构复杂度问题（职责混乱、耦合度高）问题 1：订阅地狱构造函数中硬编码了 10+ 个订阅，修改话题需要改代码并重新编译，无法灵活配置。\n我一开始觉得这样写最直接——所有订阅都在一个地方。但当我添加第 5 个模式时，我意识到这个构造函数已经成了”意大利面”。\n问题 2：巨大的 switch-case单个函数 &gt; 500 行，修改一个模式可能影响其他模式，merge 冲突频繁。\n我每次改 switch-case 都要小心翼翼。改了一个 case，又得担心另一个 case 是否会受影响。到了第 10 个模式，这个函数已经大到我根本不敢重构。\n问题 5：全局状态变量爆炸20+ 个成员变量管理各种状态，竞态条件风险高，难以跟踪状态变化。\n每添加一个新模式，我就要添加 5-10 个新的成员变量。什么 cartesian_thread_running_，stop_cartesian_thread_，active_twist_direction_ 这种。到最后，我甚至不知道这些变量是干什么的。\n\n🔌 第二类：可扩展性问题（无法配置、代码重复）问题 3：消息类型混乱每个模式用不同的消息类型，没有统一的接口，容易发送错误的消息。\nJointVelocity 订阅的是 JointState，CartesianVelocity 订阅的是 TwistStamped，MoveJ 订阅的是 Float64MultiArray。完全没有规律。新来的人要添加一个控制器，还要去翻之前的代码猜猜”应该用哪个消息类型”。\n问题 6：无法动态配置所有参数硬编码在代码中，部署不同的机器人需要修改代码。\n话题名死死地写在代码里。想在另一个机器人上跑同样的代码？改话题名，重新编译。想根据不同的配置启用&#x2F;禁用某个模式？没办法，代码里已经死了。\n问题 7：每个模式自己实现线程管理代码重复，线程频率不一致，难以统一管理生命周期。\nCartesianVelocity 用 rclcpp::Rate(50) 循环，JointVelocity 用 std::this_thread::sleep_for(100ms)。没人规定应该怎样做。复制粘贴就完事了。结果：线程泄漏、死锁、同步问题……\n\n🧪 第三类：可维护性问题（职责混乱、难以测试）问题 4：业务逻辑与基础设施混合业务逻辑、线程管理、ROS I&#x2F;O 混在一起，无法独立测试。\n想单独测试 CartesianVelocityController 的 IK 计算？不行，它和线程、锁、状态变量都混在一起。测试它就意味着要启动整个 StateMachine、初始化所有 ROS 通信。单元测试变成了”集成测试”。\n问题 8：难以测试和扩展无法独立单元测试某个控制器，耦合太严重。\n两个同事要并行开发两个新模式？10 分钟后就开始出现 merge 冲突。因为他们改的是同一个文件的不同部分——构造函数、switch-case、成员变量。一个人改了，另一个人的代码就可能和新的部分冲突。\n1.3 问题的根本原因这 8 个问题的根源不在实现细节，而在架构设计的两个核心缺陷：\n缺陷 A：中心化的”万能管理器”所有控制逻辑、消息处理、线程管理都集中在 StateMachine 一个类中。任何改动都影响整个系统。\n缺陷 B：硬编码而非配置驱动添加新模式需要修改代码的多个位置，任何配置改动都需要重新编译。\n关键洞察：这不是写法问题，而是架构设计的问题。脏架构的本质缺陷是没有清晰的职责边界。\n脏架构的本质：\n\n❌ 能工作（短期）✓\n❌ 无法成长（长期）✗\n❌ 无法预测（修改一处，不知道会否影响另一处）\n\n我们期待的理想状态（清洁架构）：\n\n✓ 添加新控制器，无需修改核心代码\n✓ 配置文件能驱动系统行为\n✓ 通信逻辑与控制逻辑完全解耦\n✓ 每个控制器可独立测试\n\n这，就是我们要在下篇实现的目标。\n\n第一部分（续）：8 个问题速览用一张表快速总结脏架构的全貌：\n\n\n\n序号\n问题名\n表现\n根本原因\n\n\n\n1️⃣\n订阅地狱\n构造函数 10+ 个硬编码订阅，修改话题需改代码重编译\n没有配置文件支持\n\n\n2️⃣\n巨大 switch-case\n500+ 行的单一函数，逻辑混乱，merge 冲突频繁\n没有工厂模式分离逻辑\n\n\n3️⃣\n消息类型混乱\n每个模式用不同消息类型，无法统一接口\n没有基类接口约束\n\n\n4️⃣\n逻辑与基础设施混合\n业务逻辑 + 线程管理 + ROS I&#x2F;O 混在一起\n没有职责分离（SRP）\n\n\n5️⃣\n状态变量爆炸\n20+ 个成员变量管理各种状态，竞态条件风险高\n没有状态封装边界\n\n\n6️⃣\n无法动态配置\n所有参数硬编码，无法参数化部署\n没有配置驱动设计\n\n\n7️⃣\n线程管理重复\n每个模式自己实现线程循环，代码重复高\n没有统一的线程抽象\n\n\n8️⃣\n难以测试和扩展\n无法独立单元测试某个控制器\n耦合太严重，无法隔离\n\n\n一句话总结：所有问题都源于同一个根因——职责没有清晰边界，所有东西混在一个文件里。\n\n第一部分（续）：脏架构的症状总结随着控制器数量增加，脏架构的代价指数级增长：\n\n\n\n控制器数量\n核心文件行数\n每个控制器成本\n维护难度\n状态\n\n\n\n1-5 个\n300-800 行\n2-4 小时\n⭐ 简单\n✓ 可接受\n\n\n5-10 个\n800-1500 行\n4-8 小时\n⭐⭐⭐ 中等\n✓ 还能接受\n\n\n10-20 个\n1500-3000 行\n8-24 小时\n⭐⭐⭐⭐⭐ 困难\n⚠️ 需要重构\n\n\n20+ 个\n3000+ 行\n24-72 小时\n⭐⭐⭐⭐⭐⭐ 极难\n❌ 不可维护\n\n\n关键观察：\n\n核心文件行数呈线性增长（每个新控制器添加 150-200 行）\n添加新控制器的成本呈指数增长（从 2h → 4h → 8h → 24h）\nmerge 冲突从偶发 → 频繁 → 每次都有\n\n当你超过 20 个控制器时，整个系统已经基本不可维护。\n\n\n第二部分 - 底层理论 - SOLID 原则在本项目中的应用清洁设计之所以有效，是因为它遵循了 SOLID 设计原则。理解这些原则能帮助我们看清脏架构为什么出现这些问题。\nS - 单一职责原则（Single Responsibility Principle）原则：一个类应该只有一个改变的理由。\n脏架构的违反：\n\nStateMachine 类同时负责：ROS 通信、模式切换、业务逻辑、线程管理、状态维护\n修改任何一个方面都要改这个类\n\n收益：\n\n修改某个控制器的逻辑，不影响 ControllerManager\n代码复用性高，易于测试\n\nO - 开闭原则（Open&#x2F;Closed Principle）原则：软件应该对扩展开放，对修改关闭。\n脏架构的违反：\n\n添加新模式 → 必须修改 StateMachine 类\n每次扩展都要改现有代码\n\n收益：\n脏架构：扩展 = 修改核心文件，风险高清洁设计：扩展 = 添加新文件，风险低\n\nL - 里氏替换原则（Liskov Substitution Principle）原则：子类应该可以替代父类，而不会导致程序出错。\n脏架构的违反：\n\n没有统一的接口，每个控制器实现都不同\n\n收益：\n\n可以轻松替换控制器实现\nControllerManager 代码永不修改\n\nI - 接口隔离原则（Interface Segregation Principle）原则：客户端不应该被迫依赖它不使用的接口。\n脏架构的违反：\n\nStateMachine 依赖 ROS、Kinematics、HardwareManager 等所有系统\n修改任何依赖都要改 StateMachine\n\n收益：\n\n修改 Kinematics → 只影响 CartesianVelocityController\nControllerManager 完全不受影响\n\nD - 依赖倒置原则（Dependency Inversion Principle）原则：高层模块不应该依赖低层模块，两者都应该依赖抽象。\n脏架构的违反：\n高层（StateMachine）    ↓ 直接依赖低层（具体控制逻辑）\n\n清洁设计的方向：\n高层（ControllerManager）    ↓ 依赖抽象（ModeControllerBase 接口）    ↓ 依赖低层（具体控制器实现）\n\nSOLID 原则对比表\n\n\n原则\n脏架构问题\n清洁设计应用\n收益\n\n\n\nS 单一职责\nStateMachine 负责所有\n每个类只做一件事\n修改隔离、易于测试\n\n\nO 开闭\n扩展&#x3D;修改核心文件\n扩展&#x3D;添加新文件\n风险低、成本恒定\n\n\nL 里氏替换\n接口不统一\n统一的 ModeControllerBase\n可随意替换\n\n\nI 接口隔离\n所有依赖混在一起\n分层隔离依赖\n改动影响小\n\n\nD 依赖倒置\n高层依赖低层\n都依赖抽象\n松耦合、易扩展\n\n\n为什么 SOLID 原则很重要SOLID 原则不是”最佳实践”的意见，而是经过几十年验证的工程原则。当你遵循这些原则时：\n\n代码变得可持续演化 - 添加功能成本恒定\n团队可以并行工作 - 不会频繁冲突\nbug 修复风险低 - 修改隔离在小范围内\n新成员易上手 - 模块化的代码更容易理解\n测试变得可行 - 解耦的代码易于单元测试\n\n这些不仅仅是”代码美观”的问题，而是影响整个项目生命周期成本的工程决策。\n一句话总结：\n\n如果你想让系统能不断添加控制器而不触碰旧代码，就必须遵守 SOLID——特别是开闭原则和依赖倒置原则。\n\n\n总结：问题诊断完成现在我们清楚地看到了脏架构的 8 个严重问题，以及它们的根本原因——职责混乱和过度耦合。\n这些问题都违反了 SOLID 原则，特别是：\n\n单一职责原则：StateMachine 职责太多\n开闭原则：每次扩展都要修改核心代码\n接口隔离原则：所有依赖混在一起\n依赖倒置原则：高层直接依赖低层实现\n\n\n下一步：清洁设计的解决方案在下篇中，我们将看到如何通过：\n\n分离职责 - 每个控制器独立成类\n配置驱动 - YAML 文件而非硬编码\n工厂模式 - 动态创建控制器\n统一接口 - 所有控制器实现同一个接口\n\n来完全解决这些问题。下篇将深入讲解清洁设计的实现细节和代码示例。\n下篇链接：从硬编码到插件化（下篇）：清洁架构的设计与实现\n","categories":["控制架构篇-从模式到工厂"],"tags":["C++","ROS2","设计模式","控制系统架构","插件化"]},{"title":"从硬编码到插件化（下篇）：清洁架构的设计与实现","url":"/2025/11/01/%E4%BB%8E%E7%A1%AC%E7%BC%96%E7%A0%81%E5%88%B0%E6%8F%92%E4%BB%B6%E5%8C%96%EF%BC%88%E4%B8%8B%E7%AF%87%EF%BC%89%EF%BC%9A%E6%B8%85%E6%B4%81%E6%9E%B6%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/","content":"\n在上篇中，我们一起经历了那段混乱的日子——函数上千行、模式互相干扰、改一处崩全局。\n本篇，我们将亲手拆解并重建这一切：从混乱到清晰，从硬编码到配置驱动。这是我项目架构演化中最关键的一步。\n\n前置阅读：从硬编码到插件化（上篇）：脏架构的问题诊断（强烈建议先阅读）\n本文适合：架构设计师、ROS2 开发者、以及想学习实际项目架构的工程师\n内容：设计理念、设计决策、完整代码实现、与 pluginlib 的对比、个人反思\n\n📖 本篇内容理念篇：从混乱到清晰的设计思想\n清洁架构的核心思想\n设计原则与关键决策\n\n实现篇：代码与架构的落地实现\n完整代码实现\n与 pluginlib 的对比\n个人反思与收益\n\n\n第一部分 - 清洁架构的核心思想从”过程式控制”到”模块化控制”在深入具体的设计细节前，必须先理解思维方式的转变。\n脏架构 vs 清洁架构：思维方式对比\n\n\n维度\n脏架构（早期）\n清洁架构（重构）\n收益\n\n\n\n控制逻辑\nStateMachine 主动命令式控制\n每个控制器自我管理生命周期\n职责清晰\n\n\n代码组织\n所有模式混在一个类中（1000+ 行）\n每个模式独立成类，实现统一接口\n易维护\n\n\n模式切换\n巨大 switch-case + 全局状态\n工厂 + 注册机制自动切换\n无 merge 冲突\n\n\n配置方式\n硬编码话题、参数、模式\nYAML 配置文件动态加载\n无需改代码\n\n\n耦合关系\n混在一起，无法隔离\n通过接口隔离，分层清晰\n可独立测试\n\n\n扩展性\n添加模式 → 改 6-8 处代码\n添加模式 → 新文件 + 改 1 行\n成本恒定\n\n\n可测试性\n无法单独测试控制器\n控制器可独立单元测试\n质量保证\n\n\n复杂度增长\n线性增长（每个模式 +150 行）\n常数增长（核心代码不变）\n可持续演化\n\n\n“清洁”的定义（在本项目语境下）清洁架构 遵循以下四条实用清洁原则：\n\n独立性：控制器可以脱离主节点单独运行、单元测试\n配置驱动：不修改代码即可添加或调整控制器\n职责单一：每个类只做一件事（SRP 原则）\n演化友好：新控制器的接入不影响旧控制器\n\n换句话说：清洁架构的目标，不是追求”优雅”的代码，而是追求**”可持续演化”的系统**。\n这意味着：\n\n添加第 10 个控制器和添加第 100 个控制器的成本大致相同\n一个控制器的 bug 修复不会影响其他控制器\n新成员加入团队不需要理解全部控制逻辑\n\n\n第二部分 - 清洁设计的原则2.0 脏架构的代价对比添加新控制器时的修改成本对比：\n\n\n\n指标\n脏架构\n清洁架构\n\n\n\n修改文件数\n6-8 个\n3 个\n\n\n修改核心代码处数\n6-8 处\n1 处\n\n\n新增总代码行数\n200-300 行\n150-250 行\n\n\n新增核心代码行数\n~100 行\n&lt; 10 行\n\n\n创建新文件\n无\n1 个（controller 类）\n\n\n开发周期\n1-3 天\n2-4 小时\n\n\nmerge 冲突风险\n高（多人改同一处）\n低（几乎无冲突）\n\n\n回归测试范围\n整个 StateMachine\n仅新控制器\n\n\n具体修改清单对比：\n脏架构需要改：\n\nrobot_state_machine.hpp - 添加 5-10 个成员变量\nrobot_state_machine.cpp 构造函数 - 添加订阅\nworking_mode_callback() - 添加 case\n新增 5 个新的回调&#x2F;线程函数\n\n清洁架构只需：\n\n创建 my_new_controller.hpp&#x2F;cpp\ncontroller_registry.cpp 添加 1 行\nconfig.yaml 添加 4 行配置\n\n2.1 核心设计目标我们希望实现一个系统，满足：\n\n配置驱动：在 YAML 中声明控制器，代码自动加载\n松耦合：添加新控制器不需要修改核心代码\n单一职责：每个控制器只管理自己\n类型安全：编译期检查，避免运行期错误\n易于扩展：新控制器开发者只需实现接口\n\n2.2 关键设计决策决策 1：使用工厂 Lambda 代替虚函数反面教材：Switch-case 的问题\n// ❌ 旧方式：巨大的 switch-casestd::shared_ptr&lt;ModeControllerBase&gt; create_controller(const std::string&amp; class_name, rclcpp::Node::SharedPtr node) &#123;    switch(hash(class_name)) &#123;        case &quot;MoveJController&quot;_hash:            return std::make_shared&lt;MoveJController&gt;(node);        case &quot;MoveLController&quot;_hash:            return std::make_shared&lt;MoveLController&gt;(node);        case &quot;CartesianVelocityController&quot;_hash:            return std::make_shared&lt;CartesianVelocityController&gt;(node);        // ... 每添加一个新控制器，这个函数就要修改！        default:            return nullptr;    &#125;&#125;\n\n这样的问题是：\n\n每个新控制器都要修改这个创建函数\nswitch-case 不断增长\n容易出现 merge 冲突\n\n// ✓ 推荐：工厂 Lambdastd::unordered_map&lt;std::string, ControllerInterface::Creator&gt; get_available_controllers() &#123;    return &#123;        &#123;&quot;MoveJController&quot;, [](rclcpp::Node::SharedPtr node) &#123;            return std::make_shared&lt;MoveJController&gt;(node); &#125;&#125;,        &#123;&quot;MoveLController&quot;, [](rclcpp::Node::SharedPtr node) &#123;            return std::make_shared&lt;MoveLController&gt;(node); &#125;&#125;,        &#123;&quot;CartesianVelocityController&quot;, [](rclcpp::Node::SharedPtr node) &#123;            return std::make_shared&lt;CartesianVelocityController&gt;(node); &#125;&#125;,        // ... 每添加一个控制器，只需添加 1 行！无需修改创建逻辑    &#125;;&#125;// 使用时：auto it = available.find(class_name);if (it != available.end()) &#123;    auto controller = it-&gt;second(node);  // 调用对应的工厂 Lambda&#125;\n\n对比：\n\n旧方式：新增控制器 → 修改创建函数 → 重新编译整个项目\n新方式：新增控制器 → 在 map 中添加一行 → 代码更新即可\n\n决策 2：使用字符串 Key 而非枚举反面教材：Enum 的维护负担\n// ❌ 旧方式：枚举 + 字符串映射enum class ControlMode &#123;    CARTESIAN_VELOCITY = 1,    JOINT_VELOCITY = 2,    MOVE_J = 3,    MOVE_L = 4,    // ... 每添加一个模式，需要添加新的枚举值&#125;;// 还需要维护一个映射表std::map&lt;ControlMode, std::string&gt; mode_to_string = &#123;    &#123;ControlMode::CARTESIAN_VELOCITY, &quot;CartesianVelocity&quot;&#125;,    &#123;ControlMode::JOINT_VELOCITY, &quot;JointVelocity&quot;&#125;,    // ... 两处都要修改！&#125;;// YAML 中mode: 1  // 用枚举值，不直观\n\n这样的问题：\n\n修改一个地方要同时改 enum 和 mapping 表\n容易遗漏或不同步\nYAML 中用数字不直观\n\n// ✓ 推荐：字符串 Keycontroller_map_[&quot;CartesianVelocity&quot;] = controller_instance;// YAML 中（完全一致，一目了然）controllers:  - key: CartesianVelocity    class: CartesianVelocityController\n\n优势：\n\nYAML 和代码中的 key 完全一致，无需转换\n添加新模式时只需在一处修改\n自描述，非常直观\n\n决策 3：使用 std::any 做消息容器问题：如何在多态的同时保持类型安全？\n一个常见的错误做法是使用 void* 的转型，这很危险：\n// ❌ 危险的 void* 转型class ModeControllerBase &#123;    virtual void handle_message(void* msg) = 0;  // 类型信息丢失！&#125;;class CartesianVelocityController : public ModeControllerBase &#123;    void handle_message(void* msg) override &#123;        // 这里需要猜测 msg 是什么类型，容易出错        auto twist = static_cast&lt;geometry_msgs::msg::TwistStamped*&gt;(msg);        // 如果 msg 实际上是其他类型，运行时会崩溃    &#125;&#125;;\n\n解决方案：std::any + 模板的组合\n// ✓ 类型安全的解决方案class ModeControllerBase &#123;    virtual void handle_message(std::any msg) = 0;  // 保留类型信息&#125;;template&lt;typename T&gt;class VelocityControllerImpl : public ModeControllerBase &#123;    void handle_message(std::any msg) override final &#123;        auto typed_msg = std::any_cast&lt;typename T::SharedPtr&gt;(msg);  // 编译期类型检查        velocity_callback(typed_msg);  // 派生类无需关心转换    &#125;&#125;;\n\n优势：\n\n编译期类型检查：类型不匹配会在编译时失败\n派生类实现者不用关心转换细节\n多态和类型安全的完美结合\n\n\n第三部分 - 清洁设计的实现3.1 核心组件ControllerInterface（中央注册表）为什么用单例？\nControllerInterface 是系统的”黄页”——全局唯一的控制器名称到创建方法的映射。它需要：\n\n全局唯一：系统只有一份注册表\n启动时初始化：在应用启动时集中填充\n线程安全：多个地方都可能查询\n与业务逻辑隔离：不涉及具体的业务状态\n\n因此单例模式是合适的选择。它不是”业务逻辑的单例”（那是反模式），而是”基础设施的单例”。\nclass ControllerInterface &#123;public:    using Creator = std::function&lt;std::shared_ptr&lt;ModeControllerBase&gt;(rclcpp::Node::SharedPtr)&gt;;    // 单例获取接口    static ControllerInterface&amp; instance() &#123;        static ControllerInterface instance;        return instance;    &#125;    // 注册控制器类    bool register_class(const std::string&amp; name, Creator creator) &#123;        return registry_.emplace(name, creator).second;    &#125;    // 创建控制器实例    std::shared_ptr&lt;ModeControllerBase&gt; create(const std::string&amp; name, rclcpp::Node::SharedPtr node) &#123;        auto it = registry_.find(name);        if (it != registry_.end()) &#123;            return it-&gt;second(node);        &#125;        return nullptr;    &#125;private:    ControllerInterface() = default;    std::unordered_map&lt;std::string, Creator&gt; registry_;&#125;;\n\n关键点：\n\n单例模式：全局唯一的注册表\n查询 O(1) 时间复杂度\n\n基类设计class ModeControllerBase &#123;public:    virtual void start(const std::string&amp; mapping = &quot;&quot;) &#123; is_active_ = true; &#125;    virtual bool stop(const std::string&amp; mapping = &quot;&quot;) &#123; is_active_ = false; return true; &#125;    virtual void handle_message(std::any msg) = 0;    virtual bool needs_hook_state() const &#123; return false; &#125;protected:    bool is_active_ = false;    std::string mode_;&#125;;\n\n工厂方法注册// controller/controller_registry.cppstd::unordered_map&lt;std::string, ControllerInterface::Creator&gt; get_available_controllers() &#123;    return &#123;        &#123;&quot;CartesianVelocityController&quot;, [](rclcpp::Node::SharedPtr node) &#123;            return std::make_shared&lt;CartesianVelocityController&gt;(node);        &#125;&#125;,        &#123;&quot;JointVelocityController&quot;, [](rclcpp::Node::SharedPtr node) &#123;            return std::make_shared&lt;JointVelocityController&gt;(node);        &#125;&#125;,        &#123;&quot;MoveJController&quot;, [](rclcpp::Node::SharedPtr node) &#123;            return std::make_shared&lt;MoveJController&gt;(node);        &#125;&#125;,        // ... 更多控制器 ...    &#125;;&#125;\n\n配置文件（config.yaml）controllers:  - key: CartesianVelocity    class: CartesianVelocityController    input_topic:      name: /controller_api/cartesian_velocity_action  - key: JointVelocity    class: JointVelocityController    input_topic:      name: /controller_api/joint_velocity_action  - key: MoveJ    class: MoveJController    input_topic:      name: /controller_api/movej_action\n\n3.2 初始化流程步骤 1：加载配置void ControllerManagerNode::load_config() &#123;    try &#123;        std::string yaml_path = pkg_path + &quot;/config/config.yaml&quot;;        yaml_config_ = YAML::LoadFile(yaml_path);        RCLCPP_INFO(get_logger(), &quot;Configuration loaded successfully&quot;);    &#125; catch (const std::exception&amp; e) &#123;        RCLCPP_FATAL(get_logger(), &quot;Failed to load configuration: %s&quot;, e.what());        rclcpp::shutdown();    &#125;&#125;\n\n步骤 2-3：初始化控制器void ControllerManagerNode::init_controllers() &#123;    try &#123;        auto available = get_available_controllers();  // 获取工厂方法        for (const auto&amp; entry : yaml_config_[&quot;controllers&quot;]) &#123;            std::string key = entry[&quot;key&quot;].as&lt;std::string&gt;();            std::string class_name = entry[&quot;class&quot;].as&lt;std::string&gt;();            auto it = available.find(class_name);            if (it != available.end()) &#123;                // 使用工厂方法创建实例                auto controller = it-&gt;second(this-&gt;shared_from_this());                // 注册到中央注册表                ControllerInterface::instance().register_class(key, it-&gt;second);                // 保存到本地 map                controller_map_[key] = controller;                RCLCPP_INFO(get_logger(), &quot;Registered controller: %s&quot;, key.c_str());            &#125;        &#125;    &#125; catch (const std::exception&amp; e) &#123;        RCLCPP_FATAL(get_logger(), &quot;Failed to initialize: %s&quot;, e.what());        rclcpp::shutdown();    &#125;&#125;\n\n3.3 添加新控制器的完整步骤现在，添加新控制器变得简单：\n步骤 1：创建新控制器类\nclass MyNewController : public VelocityControllerImpl&lt;MyMessageType&gt; &#123;    void velocity_callback(const MyMessageType::SharedPtr msg) override &#123;        // 业务逻辑    &#125;&#125;;\n\n步骤 2：在 get_available_controllers() 中添加一行\n&#123;&quot;MyNewController&quot;, [](rclcpp::Node::SharedPtr node) &#123;    return std::make_shared&lt;MyNewController&gt;(node);&#125;&#125;,\n\n步骤 3：在 YAML 中添加配置\n- key: MyNewMode  class: MyNewController  input_topic:    name: /controller_api/my_new_mode_action\n\n完成！ 系统自动加载新控制器。\n系统架构总览经过以上三步，新控制器已被整合到清洁架构中。宏观来看，系统的组织结构是这样的：\n第一层：ControllerManager（主管理器）\n\n职责：初始化、生命周期管理、模式切换\n关键方法：load_config() → init_controllers() → handle_work_mode()\n特点：代码行数保持稳定，与控制器数量无关\n\n第二层：ControllerInterface（中央注册表）\n\n职责：维护全局的控制器映射（key → factory method）\n实现方式：单例模式\n特点：启动时集中初始化，运行时 O(1) 查询\n\n第三层：各个具体控制器\n\nCartesianVelocityController（笛卡尔速度控制）\nJointVelocityController（关节速度控制）\nMoveJController（关节插值运动）\n… 更多控制器\n\n扩展流程：\n新增控制器类 (MyNewController.hpp/.cpp)           ↓在 registry.cpp 添加一行工厂方法           ↓在 config.yaml 添加控制器配置           ↓系统启动时自动加载，无需修改核心代码\n\n这个结构的核心优势：\n\n✅ ControllerManager 的代码量不增长（新增控制器对它透明）\n✅ 控制器之间完全独立（无耦合，可并行开发）\n✅ 配置驱动（YAML 修改即可启用&#x2F;禁用）\n✅ 易于测试（每个控制器可独立单元测试）\n\n\n第四部分 - 与 pluginlib 的对比对比表\n\n\n维度\n当前方案\npluginlib\n\n\n\n加载时机\n编译期\n运行期\n\n\n绑定方式\n静态链接\n动态加载（dlopen）\n\n\n配置文件\nYAML\nXML\n\n\n控制器数量\n&lt; 50 个适合\n&gt; 50 个适合\n\n\n性能\n极优（312x faster）\n足够好\n\n\n修改核心代码\n1 行\n0 行\n\n\n开发周期\n2-4 小时\n4-8 小时\n\n\n个人的实战选择坦白说，我最初尝试过 pluginlib，但发现对于频繁迭代的研发阶段，它的 XML 配置、plugin.xml 文件、CMakeLists.txt 修改和编译过程反而拖慢了开发速度。\n我需要的是快速迭代、少冲突、高性能的方案。所以在当前项目中选择了轻量级的工厂 Lambda 方案。\n关键是：一旦系统成熟、控制器稳定，我依然可以平滑迁移到 pluginlib——两者的底层设计思想是一致的，只是实现方式不同。\n何时选择哪个方案选择当前方案（推荐）如果：\n\n控制器数量 &lt; 50 个\n控制器由同一个团队维护\n系统性能要求高\n不需要运行时热加载新插件\n\n选择 pluginlib（推荐）如果：\n\n控制器数量 &gt; 50 个\n由多个独立团队贡献控制器\n需要支持第三方插件\n需要运行时更新&#x2F;替换控制器\n\n\n第五部分 - 个人反思5.1 脏架构让我吃过的苦情景 1：添加第 10 个控制器\n\n修改核心文件 6-8 处\n添加 200-300 行代码\n花费 1-3 天时间\n担心打破其他控制器\n\n情景 2：两个人并行开发\n\n频繁的 merge 冲突\n解决冲突需要 2+ 小时\n冲突本不应该发生\n\n情景 3：调试 bug\n\n一个关于线程的 bug\n整个文件 700+ 行\n花了 4 小时才找到根源\n\n情景 4：无法编写单元测试\n\nCartesianVelocityController 紧密耦合\n无法隔离单独测试\n测试 CartesianVelocityController 就意味着要启动整个 StateMachine\n\n5.2 清洁设计的转折点当控制器数量增长到 7-8 个时，我意识到这种架构已经快到临界点。\n架构演化的分界线：通常，当以下两个条件之一出现时，就是架构必须重构的信号：\n\n功能数超过 5-7 个，且核心文件变得难以维护（800+ 行）\n出现第一次「加功能比修 bug 还难」的时刻——每个新功能都要触及多个地方，风险无法控制\n\n对我来说，两个条件都出现了。新增一个控制器需要改 6-8 处地方，变成了「高风险的重体力活」。\n我的决定：重新设计，基于以下原则：\n\n每个控制器应该独立\n配置不应该在代码中\n添加新功能不应该修改核心代码\n应该可以独立测试\n\n5.3 迁移的收益迁移到清洁设计后，3 周内我添加了 8 个新控制器。\n关键数据：\n\n每个新控制器的开发时间：从 1-3 天 → 2-4 小时\n核心文件行数：保持稳定（300 行 → 310 行）\nMerge 冲突：从频繁 → 基本不出现\n单元测试：从不可能 → 轻而易举\n\n5.4 关键领悟「当代码的增长呈指数级增加时，是架构出问题了，而不是实现出问题。」\n脏架构的根本问题不在于某个控制器的实现不好，而在于管理这些控制器的方式本身就是脆弱的。\n一个隐喻：当我删掉那 500 行 switch-case 时，我意识到——好的架构不只是代码整洁，而是开发者能呼吸的空间。\n在脏架构下，我总是战战兢兢地修改代码，担心打破某处的微妙平衡。在清洁架构下，我可以专注于业务逻辑本身，信任系统的边界和约束。\n\n总结从脏到清洁的关键洞察\n\n\n问题\n脏架构的做法\n清洁设计的做法\n收益\n\n\n\n如何定义新模式？\n修改枚举\nYAML 配置\n无需改代码\n\n\n如何初始化控制器？\n硬编码 switch-case\n工厂 Lambda\n自动化、可扩展\n\n\n如何处理不同消息类型？\nvoid* 转型（危险）\nstd::any + 模板（安全）\n编译期检查\n\n\n如何使用新控制器？\n修改 3+ 处地方\n仅修改 registry.cpp + YAML\n降低错误风险\n\n\n可以支持多少个控制器？\n&lt; 10（开始混乱）\n50+ （仍然清晰）\n可扩展性\n\n\n设计原则总结\n配置驱动：用数据（YAML）表达结构，而非硬编码\n工厂模式：延迟对象创建，解耦依赖\n单例注册表：全局唯一的”黄页”\n类型安全：编译期错误 &gt; 运行期错误\n松耦合：新控制器无需修改核心代码\n\n最后的话这套设计方案是在性能、易用性、可扩展性之间的精心权衡：\n\n如果你需要极致性能 → 当前方案更优\n如果你需要极致灵活性 → pluginlib 更优\n如果你需要平衡 → 当前方案足以应对未来 3-5 年的增长\n\n关键是：理解这两种设计的哲学，根据你的实际需求做出选择。\n架构设计的艺术，就在于此。\n\n上篇回顾想回顾问题诊断？ 查看上篇：脏架构的问题诊断\n","categories":["控制架构篇-从模式到工厂"],"tags":["C++","ROS2","架构设计","工厂模式"]}]